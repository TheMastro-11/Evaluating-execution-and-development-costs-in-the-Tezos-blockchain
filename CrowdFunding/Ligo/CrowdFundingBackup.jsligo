//declare type
type holder = map<address, list<tez>>;

//declare variables and constants
const startDate : timestamp = Tezos.get_now();
const endDate : timestamp = startDate + 5;
const minAmount : tez  = 10 as mutez;
const maxAmount : tez = 1000 as mutez;
const ceiling : tez = 100000 as mutez;
const floorPrice : tez = 200 as mutez;



//entrypoints
const contribute = (contributors : holder)  => {
  //check if amount is between min and max
  assert_with_error( Tezos.get_amount() >= minAmount, "Amount too Low");
  assert_with_error( (Tezos.get_amount() <= maxAmount), "Amount too High");

  //add donator on map
  let checkContains = (contributors : holder ) => {
    return match(Map.find_opt (Tezos.get_sender(), contributors), {
      Some : _list_tez => 1,
      None : () => 2
    });
  };
  let checkResult : int = checkContains(contributors);
  
  let newMap : holder = Map.empty; //map to return after update
  let oldList : option<list<tez>> = None(); //old list of previous donation(s), if exist
  let total : tez = 0 as tez; //total sum of previous donation(s), if exist
  
  switch (checkResult) { //check result of checkContains
    case 1: //already donated
      //check if it will reach the max amount with other donation
      oldList = Map.find_opt(Tezos.get_sender(), contributors);
      for (const i of oldList) {
        total = total + i
      };
      assert_with_error((total <= maxAmount), "Max amount reached");

      //add new donation to oldList
      oldList = Map.find_opt(Tezos.get_sender(), contributors);
      newMap = Map.update(Tezos.get_sender(), Some(list([Tezos.get_amount(), oldList])), contributors);
      break;
    case 2: //new bidder  
      newMap = Map.add(Tezos.get_sender(), list([Tezos.get_amount()]), contributors);
      break;
  };

  return newMap
  };

const checkEnding = (contributors : holder) : bool =>{
  let donationList : list<tez> = list([]); //list of previous donation(s)
  let total : tez = 0 as tez; //total sum of donation(s)
  let getKey = (map : holder) : address => 
    match(map, {
      (key, value) : key => key,
      Default : () => failwith("Error")
    });
  if (Tezos.get_balance() > floorPrice) { //if balance is over than the crowdfunding had reached the goal
    return true
  }; else { //otherwise the contract has to refund all the donators
    for (const i of contributors){
      let key : address = getKey(contributors);   
      for (const j of donationList){
        total = total + j
      };
      Tezos.transaction(unit, total,   
        match ((Tezos.get_contract_opt(i) as option<contract<unit>>), {
          Some: (contract : contract<unit>) => contract,
          None: () => (failwith ("Not a contract") as contract<unit>)
        })) //refund
    };
    return false
  };
};
  

/* Main access point that dispatches to the entrypoints according to
   the smart contract parameter. */
const main = ([_parameter, contractStorage] : [int, holder]) : [list<operation> , holder] => {
  //define contributors map and isSuccess condition
  let contributors : holder = Map.empty;
  let isSuccess : bool = false;

  //first Contribute
  contributors = contribute(contractStorage);
  //check if time is over
  if (Tezos.get_now() > endDate){
    isSuccess = checkEnding(contributors);
  }
  
 return [
    list([]), contributors
  ]
}; 
