archetype crowdfunding

//state machine
states = 
| funding initial 
| timeOver
| airdrop
| refund

//declare variable, constant and asset
constant startDate : date = now
constant endDate : date = now + 1d
variable contributors : map<address, list<tez>> = []
constant minAmount : tez = 10utz
constant maxAmount : tez = 1000utz
constant ceiling : tez = 100000utz
constant floorPrice : tez = 200utz
variable isSuccess : bool = false


//transitions
transition airdrop_1 () {
    from funding 
        to airdrop
    with effect{isSuccess := true}
}

transition time_Over () {
    from funding 
        to timeOver
    when {now > endDate}
}

transition airdrop_2 () {
    from timeOver 
        to airdrop
    when {balance >= floorPrice}
    with effect {isSuccess := true}
}

transition refund_ () {
    from timeOver
        to refund
    when {balance < floorPrice}
}

//entrypoints
entry contribute () {
    //check if ceiling is reached
    if balance + transferred >= ceiling then
        //call transition
        transfer 0tz to entry self.airdrop_1()
    else
    
    //check if amount is between min and max
    if transferred < minAmount or transferred > maxAmount then
        fail("Amount incorrect");

    //add donator on map
    var tmp : list<tez> =  [0utz]; //local variable 
    if contributors.contains(caller) then begin
        //check if it will reach the max amount with other donation
        tmp ?:= contributors[caller] : "Error";
        if checkTotal(tmp) + transferred > maxAmount then
            fail("Reached max Amount");
        
        tmp.prepend(transferred); //add new donation with the other
        contributors.put(caller, tmp) //update value
    end
    else
        contributors.put(caller, [transferred]) //add new donator
    
}

function checkTotal(lst : list<tez>) : tez {
    var total : tez = 0utz;
    
    //sum all the elements of list
    for e in lst do
        total += e
    done;

    return total
}

