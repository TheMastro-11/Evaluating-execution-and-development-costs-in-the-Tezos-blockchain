//declare type
type holder = map<address, list<tez>>;

//declare variables and constants
const startDate : timestamp = Tezos.get_now();
const endDate : timestamp = startDate + 5;
const minAmount : tez  = 10 as mutez;
const maxAmount : tez = 1000 as mutez;
const ceiling : tez = 100000 as mutez;
const floorPrice : tez = 200 as mutez;



//entrypoints
const contribute = (contributors : holder) : holder => {
  //check if amount is between min and max
  assert_with_error( Tezos.get_amount() >= minAmount, "Amount too Low");
  assert_with_error( (Tezos.get_amount() <= maxAmount), "Amount too High");

  //add donator on map
  let checkContains = (contributors : holder) => {
    return match(Map.find_opt (Tezos.get_sender(), contributors), {
      Some : _list_tez => 1,
      None : () => 2
    });
  };
  let checkResult : int = checkContains(contributors);
  
  let newMap : holder = Map.empty; //map to return after update
  let oldList : list<tez> = list([]); //old list of previous donation(s), if exist
  let total : tez = 0 as tez; //total sum of previous donation(s), if exist
  
  switch (checkResult) { //check result of checkContains
    case 1: //already donated
      //check if it will reach the max amount with other donation
      for (const i of oldList) {
        total = total + i
      };
      assert_with_error((total <= maxAmount), "Max amount reached");

      //add new donation to oldList
      oldList = Map.find_opt(Tezos.get_sender(), contributors);
      newMap = Map.update(Tezos.get_sender(), Some(list([Tezos.get_amount(), oldList])), contributors);
      break;
    case 2: //new bidder  
      newMap = Map.add(Tezos.get_sender(), list([Tezos.get_amount()]), contributors);
      break;
  };

  return newMap
  };
  

/* Main access point that dispatches to the entrypoints according to
   the smart contract parameter. */
const main = ([_parameter, contractStorage] : [int, holder]) : [list<operation> , holder] => {
  //define contributors map and isSuccess condition
  let contributors : holder = Map.empty;
  let _isSuccess : bool = false;

  //first Contribute
  contributors = contribute(contractStorage);

 return [
    list([]), contributors
  ]
}; 
